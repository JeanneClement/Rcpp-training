---
classoption: table, dvipsname
colorlinks: no
fontsize: 10pt
link-citations: yes
linkcolor: Black
output:
  beamer_presentation:
    includes:
      after_body: doc_suffix.tex
      before_body: doc_prefix.tex
      in_header: header.tex
    slide_level: 3
urlcolor: Maroon
---

```{r options, include=FALSE}
library(knitr)
library(kableExtra)
opts_chunk$set(echo=TRUE, cache=TRUE,
               #results="hide", 
               warning=FALSE,
               message=FALSE, highlight=TRUE,
               fig.show="hide", size="small",
               fig.align="center",
               tidy=FALSE)
options(knitr.kable.NA="-")
```

\frametitle{Outline}
  \begin{columns}[c]
    \begin{column}{0.5\textwidth}
      \tableofcontents[sections=1]
    \end{column}
      \begin{column}{0.5\textwidth}
      \tableofcontents[sections=2]
      \vspace{0.5cm}
      \tableofcontents[sections=3]
      \vspace{0.5cm}
      \tableofcontents[sections=4]
    \end{column}
  \end{columns}

<!-- ================================================================= -->
<!-- PART 1: Rcpp* packages -->
<!-- ================================================================= -->

# Short presentation of Rcpp* packages

## Rcpp : extending R with C++

### Rcpp R package

- **Rcpp** is an R package to extend R with C++ code

- Main advantage: C++ is fast, it accelerates R (see next sections)

- Written by **Dirk EDDELBUETTEL** and **Romain FRANCOIS**

- <http://www.rcpp.org/>

### Simple Rcpp example

**C++ code** (in file `Code/addition.cpp`)
```{Rcpp Rcpp-addition, eval=FALSE}
#include <Rcpp.h>
using namespace Rcpp;
// [[Rcpp::export]]
int addition(int a, int b) {
  return a + b;
}
```

**R code**
```{r addition-r}
Rcpp::sourceCpp("Code/addition.cpp")
addition(2, 2)
```

### Rcpp advantages

**Thanks to `Rcpp::sourceCpp()`**

- Compile the C++ code

- Export the function to the R session

- Direct interchange of R objects (including S3, S4) between R and C++

- ... (many more, see `vignette("Rcpp-package")`)

## RcppGSL for fast random draws

### GSL and RcppGSL

\bcols
\bcol{0.1\textwidth}
\includegraphics[height=1.5cm]{figs/logo_GNU.png}
\ecol
\bcol{0.9\textwidth}

**GNU Scientific Library**

- Numerical library for C and C++ programmers

- Reliable random number generator algorithms

- Thoroughly tested and fast random number distributions

- Linear algebra (matrices and vectors)

- <https://www.gnu.org/software/gsl/>

\vspace{0.5cm}

**RcppGSL**

- Interface between R and GSL

- Using Rcpp to interface R and C

- <http://dirk.eddelbuettel.com/code/rcpp.gsl.html>

\ecol
\ecols

### GSL random number distributions

- GSL v2.6 includes **38 random number distributions** (see [GNU GSL](https://www.gnu.org/software/gsl/doc/html/randist.html))

- It's easy to implement additional random number distributions from the GSL base distributions (e.g. truncated normal distribution)

- For comparison, R API includes "only" 24 random number distributions (see [Writing R Extensions](https://cran.r-project.org/doc/manuals/r-release/R-exts.html#Distribution-functions))

- Random draws are faster with GSL than with R (eg. `gsl_ran_gamma()` vs. `R::rgamma()`)

### RcppGSL example

**C++ code**
```{Rcpp RcppGSL-my_rnorm}
#include <Rcpp.h>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
using namespace Rcpp;
// [[Rcpp::depends(RcppGSL)]]
// [[Rcpp::export]]
Rcpp::NumericVector my_rnorm(int nsamp, double mu,
                             double sigma) {
	gsl_rng *s = gsl_rng_alloc(gsl_rng_mt19937); // Random seed
	Rcpp::NumericVector beta(nsamp);
	for (int i = 0; i < nsamp; i++) {
		beta[i] = mu + gsl_ran_gaussian(s, sigma); // Random draw
	}
	return beta;
}
```

### RcppGSL example
\vspace{0.3cm}
**R code**
```{r r-my_rnorm, fig.show="asis", out.width="70%"}
library(Rcpp)
library(RcppGSL)
beta <- my_rnorm(100, 5, 2)
par(cex=2)
hist(beta)
```

## RcppArmadillo for high-performance linear algebra

### Armadillo and RcppArmadillo

\bcols
\bcol{0.1\textwidth}
\includegraphics[height=1.5cm]{figs/logo_Armadillo.png}  
\ecol
\bcol{0.9\textwidth}

**Armadillo**

- C++ library for linear algebra and scientific computing

- Provides high-level syntax and functionality: speed and ease of use

- Classes for vectors, matrices and cubes

- Matrix operations, matrix decomposition, linear model solver, etc.

- <http://arma.sourceforge.net/>

\vspace{0.5cm}

**RcppArmadillo**

- Interface between R and Armadillo

- Using Rcpp to interface R and C++

- <http://dirk.eddelbuettel.com/code/rcpp.armadillo.html>

\ecol
\ecols

### RcppArmadillo example

**C++ code**
```{Rcpp RcppArma-example}
#include <RcppArmadillo.h>
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]
Rcpp::List fastLm(const arma::mat& X, const arma::colvec& y) {
    int n = X.n_rows, k = X.n_cols;
        
    arma::colvec coef = arma::solve(X, y);    // fit model y ~ X
    arma::colvec res  = y - X*coef;           // residuals
    // std.errors of coefficients
    double s2 = std::inner_product(res.begin(), 
                                   res.end(), 
                                   res.begin(), 0.0)/(n - k);
                                                        
    arma::colvec std_err = arma::sqrt(s2 * 
      arma::diagvec(arma::pinv(arma::trans(X)*X)));
    return Rcpp::List::create(Rcpp::Named("coefficients") = coef,
                        Rcpp::Named("stderr")       = std_err,
                        Rcpp::Named("df.residual")  = n - k);
}
```

### RcppArmadillo example

**R code**
```{r r-RcppArma-example}
library(Rcpp)
library(RcppArmadillo)
# Trees data-set
y <- log(trees$Volume)
X <- cbind(1, log(trees$Girth))
# fastLm
mod <- fastLm(X, y)
mod$coef
```

### Licenses

- Licenses: GNU General Public License, Apache License 2.0 for Armadillo
- Free software licenses: we can use, modify and redistribute these softwares

# Application examples

## Distance computation 

### Distance computation 

**C++ code** (in file `Code/arma_distmat.cpp`)
```{Rcpp arma_distmat}
#include <RcppArmadillo.h>
// [[Rcpp::depends(RcppArmadillo)]]
using namespace Rcpp;
using namespace arma;

// [[Rcpp::export]]
arma::mat arma_distmat(const arma::mat& x) { 
  
  int np = x.n_rows;
  
  arma::mat distmat; distmat.zeros(np, np);
  for (int i = 0; i < np; i++) {
    arma::vec p0 = x.row(i).t();
    for (int j = i + 1; j < np; j++) {
      arma::vec p1 = x.row(j).t();
      arma::vec diff = p0 - p1;
      double squared_diff = as_scalar(diff.t() * diff);
      distmat(j, i) = distmat(i, j) = sqrt(squared_diff);
    }
  }
  return distmat;
}
```

### Distance computation 
**R code**
```{r R_distmat}
R_distmat <- function(X){
  np <- nrow(X)
  distmat <- matrix(0,nrow=np,ncol=np)
  for (i in 1:(np-1)) {
    p0 <- X[i,]
    for (j in (i+1):np){
    p1 <- X[j,]
    diff <- p0-p1
    squared_diff <- t(diff)%*% diff
    distmat[j,i] <- distmat[i,j] <- sqrt(squared_diff)
    }
  }
 return(distmat)
}
```

### Distance computation 
\vspace{0.5cm}
\bcols
\bcol{0.5\textwidth}
**1000 points dispersed all over the space : **
\vspace{0.2cm}
```{r points-representation, echo=F,  fig.show="asis", out.width="100%",out.height="70%"}
# Spatial representation of points  
X <- matrix(runif(2000,0,100),ncol=2)
plot(X[,1],X[,2],pch=4,xlab="x", ylab="y", main="Spatial repartition of points", cex.main=1.5)
```
\ecol
\bcol{0.5\textwidth}
**Distance matrix for 6 points : **
\vspace{0.1cm}
```{r distance-matrix, echo=F}
distmat <- arma_distmat(X)
knitr::kable(distmat[1:6,1:6], digits=1, booktabs=TRUE) %>%
		kableExtra::kable_styling(latex_options=c("HOLD_position","striped"),
		                          full_width=FALSE, font_size=8)
```
\vspace{3cm}
\ecol
\ecols 

### Distance computation 
**Comparison of compilation times**
```{r dist-benchmark}
Rcpp::sourceCpp("Code/arma_distmat.cpp")
library(rdist)
# Benchmark
library(rbenchmark)
Benchmark <- benchmark(
  "arma_distmat" = {arma_distmat(X)},
  "cdist" = {cdist(X,X)},
  "R_distmat" = {R_distmat(X)},
  replications=30,
  columns = c("test", "elapsed", "relative"))
knitr::kable(Benchmark,digits=1, booktabs=TRUE) %>%
		kableExtra::kable_styling(latex_options=c("HOLD_position","striped"),
		                          full_width=FALSE)
```

## Simple linear regression 

### Simple linear regression 

**C++ code**
```{Rcpp fastLm}
#include <RcppArmadillo.h>
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]
Rcpp::List arma_fastLm(const arma::mat& X, const arma::colvec& y) {
    int n = X.n_rows, k = X.n_cols;
        
    arma::colvec coef = arma::solve(X, y);    // fit model y ~ X
    arma::colvec res  = y - X*coef;           // residuals
    // std.errors of coefficients
    double s2 = arma::sum(res.t()*res);
    arma::colvec std_err = arma::sqrt(s2 * 
      arma::diagvec(arma::pinv(arma::trans(X)*X)));
    return Rcpp::List::create(Rcpp::Named("coefficients") = coef,
                        Rcpp::Named("stderr") = std_err,
                        Rcpp::Named("residuals")  = res,
                        Rcpp::Named("df.residual")  = n - k);
}
```

### Simple linear regression 
**R code**
```{r r-fastLm}
R_fastLm <- function(X, y) {
n <- nrow(X)
k <- ncol(X)

# fit model y ~ X       
coef <-solve(t(X) %*% X) %*% t(X) %*% y
# residuals
res <- y - X %*% coef
# std.errors of coefficients
s2 = sum(t(res) %*% res)/(n - k);
std_err = sqrt(s2 %*% diag(solve(t(X)%*%X)))
return(list("coefficients" = coef,
            "stderr" = std_err,
            "residuals" = res,
            "df.residual" = n - k))
}
```

### Simple linear regression 
**Comparison of compilation times**
```{r lin-benchmark}
# Data simulation
X <- matrix(rnorm(500000),ncol=100)
y <- rnorm(5000)
# Call C++ function
Rcpp::sourceCpp("Code/arma_fastLm.cpp")
# Benchmark
library(rbenchmark)
Benchmark <- benchmark(
  "arma_fastLm" = {arma_fastLm(X,y)},
  "R_fastLm" = {R_fastLm(X,y)},
  replications=30,
  columns = c("test", "elapsed", "relative"))
knitr::kable(Benchmark,digits=1, booktabs=TRUE) %>%
		kableExtra::kable_styling(latex_options=c("HOLD_position","striped"),
		                          full_width=FALSE, font_size=8)
```

### Representation of results 

## Exercise to do yourself 

### Exercise to do yourself

Implement a function in C++ to select in a matrix the lines identified by a vector of integer and return the corresponding matrix.
\vspace{0.2cm}

**C++ code**
```{Rcpp}
#include <RcppArmadillo.h>
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]
arma::mat mat_select_lines(arma::mat& X, arma::uvec& rowId) {
  int nrows = rowId.n_elem;
  int ncols = X.n_cols;
  arma::mat R(nrows, ncols);
  for(int i = 0; i < nrows; i++) {
    for(int j = 0; j < ncols; j++) {
      R(i, j) = X(rowId(i), j);
    }
  }
  return R;
}
```


# Build of R package using Rcpp

## Usefull functions

### How to build an R package around C++ functions 

- `Rcpp.package.skeleton()` to generate a new Rcpp package (modifying `DESCRIPTION` and `NAMESPACE`)
  
- `Rcpp::compileAttributes()` scans the C++ files and generates the `RcppExports.cpp` file to make the functions preceded by `// [[Rcpp::export]]` available in R.

- Implement R functions that checks the conformity of user-defined parameters, calls functions in C++ and returns the results in an easy-to-use format.


## Example of package using Rcpp

### jSDM R package
\vspace{0.2cm}
\begin{center}
\includegraphics[width=0.9\textwidth, height = 0.65\textheight]{figs/jSDM-website.png}
\end{center}
\vspace{0.2cm}

- <https://ecology.ghislainv.fr/jSDM>
  
- Made with Rcpp* packages
